---
- id: nodesecurity:npm:openwhisk:2018-04-25
  title: Remote Memory Exposure
  description: "Versions of `openwhisk` before 3.3.1 are vulnerable to remote memory
    exposure.\n\nWhen a number is passed to `api_key`, affected versions of `openwhisk`
    allocate an uninitialized buffer and send that over network in Authorization header
    (base64-encoded).\n\nProof of concept:\n\n```js\nvar openwhisk = require('openwhisk');\nvar
    options = {\n  apihost: '127.0.0.1:1433', \n  api_key: USERSUPPLIEDINPUT // number\n};\nvar
    ow = openwhisk(options);\now.actions.invoke({actionName: 'sample'}).then(result
    => console.log(result))\n```"
  affected_package: openwhisk
  vulnerable_versions:
  - "<3.3.1"
  patched_versions:
  - ">=3.3.1"
  severity: medium
  package_manager: npm
  credit:
  - Сковорода Никита Андреевич
  references:
  - https://github.com/openwhisk/openwhisk-client-js/pull/34)
  source_url: https://nodesecurity.io/advisories/600
- id: snykio:npm:openwhisk:2017-07-18
  title: Uninitialized Memory Exposure
  description: |
    [openwhisk][1] JavaScript client library for the Apache OpenWhisk
    platform.

    Affected versions of the package are vulnerable to Uninitialized Memory
    Exposure. If an openwhisk action uses a `api_key` option with a numeric
    value, then uninitialized memory might be exposed by the client.



    [1]: https://github.com/apache/incubator-openwhisk-client-js
    \n[openwhisk][1] JavaScript client library for the Apache OpenWhisk
    platform.

    Affected versions of the package are vulnerable to Uninitialized Memory
    Exposure. If an openwhisk action uses a `api_key` option with a numeric
    value, then uninitialized memory might be exposed by the client.



    [1]: https://github.com/apache/incubator-openwhisk-client-js
    \n[openwhisk][1] JavaScript client library for the Apache OpenWhisk
    platform.

    Affected versions of the package are vulnerable to Uninitialized Memory
    Exposure. If an openwhisk action uses a `api_key` option with a numeric
    value, then uninitialized memory might be exposed by the client.



    [1]: https://github.com/apache/incubator-openwhisk-client-js
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    Initializing a `options.api_key` option in such manner will cause
    uninitialized memory to be exposed.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        var openwhisk = require('openwhisk');
        var options = {apihost: '127.0.0.1:1433', api_key: 50};
        var ow = openwhisk(options);
        ow.actions.invoke({actionName: 'sample'}).then(result => console.log(result))

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    You can read more about the insecure `Buffer` behavior [on our blog][1].



    [1]: https://snyk.io/blog/exploiting-buffer/
  affected_package: openwhisk
  vulnerable_versions:
  - "<3.3.1"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-201
  credit:
  - ChALkeR
  references:
  - https://github.com/openwhisk/openwhisk-client-js/pull/34
  - https://github.com/apache/incubator-openwhisk-client-js/commit/0e40671e75d2ec7e88fa39ef787526d4304f2aaa
  source_url: https://snyk.io/vuln/npm:openwhisk:20170302
