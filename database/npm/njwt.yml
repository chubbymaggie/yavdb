---
- id: nodesecurity:npm:njwt:2018-08-02
  title: Out-of-bounds read
  description: "All versions of `njwt` are vulnerable to out-of-bounds reads when
    a number is passed into the `base64urlEncode` function. \n\nOn Node.js 6.x or
    lower this can expose sensitive information and on any other version of Node.js
    this creates a Denial of Service vulnerability."
  affected_package: njwt
  vulnerable_versions:
  - "<=99.999.99999"
  patched_versions:
  - "<0.0.0"
  severity: high
  package_manager: npm
  credit:
  - Сковорода Никита Андреевич
  references:
  - https://hackerone.com/reports/321704)
  source_url: https://nodesecurity.io/advisories/679
- id: snykio:npm:njwt:2018-06-14
  title: Uninititialized Memory Exposure
  description: |+
    [njwt][1] is the cleanest JSON Web Token (JWT) library for Node.js
    developers..

    Affected versions of this package are vulnerable to Uninitialized Memory
    Exposure. A malicious user could extract sensitive data from
    uninitialized memory or to cause a DoS by passing in a large number, in
    setups where typed user input can be passed.

    **Note** Uninitialized Memory Exposure impacts only Node.js 6.x or
    lower, Denial of Service impacts any Node.js version.



    [1]: https://www.npmjs.com/package/njwt
    \n[njwt][1] is the cleanest JSON Web Token (JWT) library for Node.js
    developers..

    Affected versions of this package are vulnerable to Uninitialized Memory
    Exposure. A malicious user could extract sensitive data from
    uninitialized memory or to cause a DoS by passing in a large number, in
    setups where typed user input can be passed.

    **Note** Uninitialized Memory Exposure impacts only Node.js 6.x or
    lower, Denial of Service impacts any Node.js version.



    [1]: https://www.npmjs.com/package/njwt
    \n[njwt][1] is the cleanest JSON Web Token (JWT) library for Node.js
    developers..

    Affected versions of this package are vulnerable to Uninitialized Memory
    Exposure. A malicious user could extract sensitive data from
    uninitialized memory or to cause a DoS by passing in a large number, in
    setups where typed user input can be passed.

    **Note** Uninitialized Memory Exposure impacts only Node.js 6.x or
    lower, Denial of Service impacts any Node.js version.



    [1]: https://www.npmjs.com/package/njwt
    \n[njwt][1] is the cleanest JSON Web Token (JWT) library for Node.js
    developers..

    Affected versions of this package are vulnerable to Uninitialized Memory
    Exposure. A malicious user could extract sensitive data from
    uninitialized memory or to cause a DoS by passing in a large number, in
    setups where typed user input can be passed.

    **Note** Uninitialized Memory Exposure impacts only Node.js 6.x or
    lower, Denial of Service impacts any Node.js version.



    [1]: https://www.npmjs.com/package/njwt
    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

    \nThe Buffer class on Node.js is a mutable array of binary data, and can
    be initialized with a string, array or number.

        const buf1 = new Buffer([1,2,3]);
        // creates a buffer containing [01, 02, 03]
        const buf2 = new Buffer('test');
        // creates a buffer containing ASCII bytes [74, 65, 73, 74]
        const buf3 = new Buffer(10);
        // creates a buffer of length 10

    The first two variants simply create a binary representation of the
    value it received. The last one, however, pre-allocates a buffer of the
    specified size, making it a useful buffer, especially when reading data
    from a stream. When using the number constructor of Buffer, it will
    allocate the memory, but will not fill it with zeros. Instead, the
    allocated buffer will hold whatever was in memory at the time. If the
    buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive
    information like keys, source code, and system info.

  affected_package: njwt
  vulnerable_versions:
  - "*"
  severity: low
  package_manager: npm
  cwe:
  - CWE-502
  credit:
  - ChALkeR
  references:
  - https://hackerone.com/reports/321704
  source_url: https://snyk.io/vuln/npm:njwt:20180614
