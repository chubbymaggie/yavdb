---
- id: ossindex:npm:angular:1970-01-01
  title: Cross Site Scripting (XSS) in JSONP
  description: JSONP allows untrusted resource URLs, which provides a vector for attack
    by malicious actors.
  affected_package: angular
  vulnerable_versions:
  - "<1.6.0-rc.0"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/commit/6476af83cd0418c84e034a955b12a842794385c4
  - https://github.com/angular/angular.js/issues/11352
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: "[Duplicate] Code injection"
  description: |-
    See https://ossindex.net/resource/vulnerability/8399952527

    There is a possible code injection made possible by allowing the passing of functions to Array.sort
  affected_package: angular
  vulnerable_versions:
  - ">1.3.0-beta.1 <1.3.0-rc.1"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/commit/b39e1d47b9a1b39a9fe34c847a81f589fba522f8#1
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Code injection
  description: "There is a possible code injection made possible by allowing the passing
    of functions to Array.sort\n\n"
  affected_package: angular
  vulnerable_versions:
  - ">=1.2.19 <1.2.19"
  - ">1.3.0-beta.1 <1.3.0-rc.1"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/commit/b39e1d47b9a1b39a9fe34c847a81f589fba522f8
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-12-30
  title: Cross Site Scripting (XSS) in server rendered templates
  description: "> When rendering Angular templates with a server-side templating engine
    like ERB or Haml it is easy to introduce XSS vulnerabilities. These vulnerabilities
    are enabled by AngularJS evaluating user-provided strings containing interpolation
    symbols (default symbols are {{ and }}).\n> \n> -- [github.com](https://github.com/angular/angular.js/issues/5601)\n"
  affected_package: angular
  vulnerable_versions:
  - "<1.3.0-beta.10"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/79.html
  - https://github.com/angular/angular.js/commit/e3f78c17d3b5d3a714402d7314094aabe7f6512a
  - https://github.com/angular/angular.js/issues/5601
  - https://github.com/angular/angular.js/issues/7496
  - https://github.com/angular/angular.js/pull/7517
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Arbitrary Code Execution
  description: SVG animations tags are not being sanitized properly, resulting in
    possible arbitrary code execution.
  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-beta.2"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/78.html
  - https://github.com/angular/angular.js/commit/67688d5ca00f6de4c7fe6084e2fa762a00d25610
  - https://github.com/angular/angular.js/pull/11290
  - https://srcclr.com/security/arbitrary-code-execution-through-svg/javascript/s-2253
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-12-30
  title: Cross Site Scripting (XSS) when loaded from an extension
  description: "> Extension URIs (`resource://...`) bypass Content-Security-Policy
    in Chrome and Firefox and can always be loaded. Now if a site already has a XSS
    bug, and uses CSP to protect itself, but the user has an extension installed that
    uses Angular, an attacke[r] can load Angular from the extension, and Angular's
    auto-bootstrapping can be used to bypass the victim site's CSP protection.\n>
    \n> -- [github.com](https://github.com/angular/angular.js/pull/15346)"
  affected_package: angular
  vulnerable_versions:
  - ">=1.5.0 <1.5.9"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/79.html
  - https://github.com/angular/angular.js/commit/0ff10e1b56c6b7c4ac465e35c96a5886e294bac5
  - https://github.com/angular/angular.js/issues/15346
  - https://github.com/angular/angular.js/pull/15346
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-12-30
  title: Cross Site Scripting (XSS) through use elements referencing external SVG
  description: "> The use element can reference external svg's (same origin) and can
    include\nxlink javascript urls or foreign object that can execute xss.\n> \n>
    -- [github.com](https://github.com/angular/angular.js/pull/13453)"
  affected_package: angular
  vulnerable_versions:
  - "<1.5.0"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/79.html
  - https://github.com/angular/angular.js/issues/13453
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-11-13
  title: Cross Site Scripting (XSS)
  description: The linky filter is vulnerable to XSS due to its usage of the unsafeHTML
    filter.
  affected_package: angular
  vulnerable_versions:
  - "<0.9.1"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/79.html
  - https://github.com/angular/angular.js/issues/34
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: UI Redress Attack Through Improper Sanitization Of SVG Elements
  description: 'angular is susceptible to UI redress attacks. The vulnerability is
    due to the lack of proper sanitisation of an html input string by stripping all
    potentially dangerous tokens. So, an attacker can place svg elements outside of
    the containing element, leading to rendering it over other elements on the page
    (example: a login link).'
  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-beta.2"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/commit/181fc567d873df065f1e84af7225deb70a8d2eb9
  - https://github.com/angular/angular.js/pull/12524
  - https://srcclr.com/security/ui-redress-attack-through-improper/javascript/s-2252
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Possible security hold with usemap attribute
  description: The attribute usemap has been blacklisted as it can be used as a security
    exploit.
  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-rc.2"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/blob/master/CHANGELOG.md#1
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Expression sandbox bypass
  description: 'These issues affect only applications with known server-side XSS holes
    that are also using CSP to secure their client-side code. '
  affected_package: angular
  vulnerable_versions:
  - "<1.3.2"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/blob/master/CHANGELOG.md
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Angular Js Sandbox Bypass
  description: The AngularJS sandbox can be bypassed, allowing the execution of arbitrary
    JavaScript from within the Angular scope.
  affected_package: angular
  vulnerable_versions:
  - ">1.3.0-beta.1 <1.3.0-rc.1"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - http://avlidienbrunn.se/angular.txt#1
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Arbitrary code execution
  description: Arbitrary code execution was possible under very specific conditions.
  affected_package: angular
  vulnerable_versions:
  - ">1.3.0-beta.1 <1.3.0-beta.14"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://github.com/angular/angular.js/blob/b3b5015cb7919708ce179dc3d6f0d7d7f43ef621/CHANGELOG.md#1
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: AngularJS Sandbox Bypass
  description: "The AngularJS sandbox can be bypassed, allowing the execution of arbitrary
    JavaScript from within the Angular scope.\n\n"
  affected_package: angular
  vulnerable_versions:
  - ">=1.2.19 <1.2.24"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - http://avlidienbrunn.se/angular.txt
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-07-28
  title: Injection Attack
  description: AngularJS offers frontend developers a scope object that attempts to
    isolate global variables from the templating work-flow and keep things lean and
    "Angular-only". This makes sense - and to be fair, the AngularJS documentation
    explicitly states that the scope object is not considered to be a sandbox. And
    indeed it is none. With a simple JavaScript trick one can break out of this "non-sandbox"
    and execute arbitrary code in window and other host objects.
  affected_package: angular
  vulnerable_versions:
  - "<1.2.0"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://code.google.com/p/mustache-security/wiki/AngularJS
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: ossindex:npm:angular:2016-04-29
  title: Cross Site Scripting (XSS) in ng-srcset
  description: |-
    There is a security issue with ng-srcset; URIs aren't sanitized.

    The behavior is correct for ng-src but not for ng-srcset. The problem is with src/ng/compile.js that it ignores srcset.
  affected_package: angular
  vulnerable_versions:
  - "<1.3.0-rc.3"
  package_manager: npm
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/79.html
  - https://github.com/angular/angular.js/pull/8975
  source_url: https://ossindex.net/resource/package/7012057027/vulnerabilities
- id: snykio:npm:angular:2018-02-02
  title: Cross-site Scripting (XSS)
  description: |+
    [`angularjs`][1] is a toolset for building the framework suited to your
    application development.

    Affected versions of this package are vulnerable to Cross-site Scripting
    (XSS) through SVG files if enableSvg is set.



    [1]: https://www.npmjs.com/package/angularjs
    \n[`angularjs`][1] is a toolset for building the framework suited to your
    application development.

    Affected versions of this package are vulnerable to Cross-site Scripting
    (XSS) through SVG files if enableSvg is set.



    [1]: https://www.npmjs.com/package/angularjs
    \n[`angularjs`][1] is a toolset for building the framework suited to your
    application development.

    Affected versions of this package are vulnerable to Cross-site Scripting
    (XSS) through SVG files if enableSvg is set.



    [1]: https://www.npmjs.com/package/angularjs
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.6.9"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Unknown
  references:
  - https://github.com/angular/angular.js/blob/master/CHANGELOG.md#169-fiery-basilisk-2018-02-02
  source_url: https://snyk.io/vuln/npm:angular:20180202
- id: snykio:npm:angular:2017-10-17
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \n[`angular`][1] is an HTML enhanced for web apps.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via ideographic space chararcters in URIs.

    Browsers mutate attributes values such as `　javascript:alert(1)` when
    they are written to the DOM via `innerHTML` in various vendor specific
    ways. In Chrome (&lt;62), this mutation removed the preceding
    \"whitespace\" resulting in a value that could end up being executed as
    JavaScript.

    Here is an example of what could happen:

        // Code goes here
        var h1 = document.querySelector('h1');
        h1.innerHTML = '<a href="　javascript:alert(1)">CLICKME</a>';
        var innerHTML = h1.innerHTML;
        console.log(innerHTML);
        h1.innerHTML = innerHTML;

    The sanitizer contains a bit of code that triggers this mutation on an
    inert piece of DOM, [before angular sanitizes it][2].

    **Note:** Chrome 62 does not appear to mutate this particular string any
    more, instead it just leaves the \"whitespace\" in place. This probably
    means that Chrome 62 is no longer vulnerable to this specific attack
    vector.



    [1]: https://www.npmjs.com/package/angular
    [2]: https://github.com/angular/angular.js/blob/817ac567/src/ngSanitize/sanitize.js#L406-L417
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.6.7"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Unknown
  references:
  - https://github.com/angular/angular.js/pull/16311
  - https://github.com/angular/angular.js/issues/16288
  - https://github.com/angular/angular.js/commit/667db466f959f8bbca1451d0f1c1a3db25d46a6c
  source_url: https://snyk.io/vuln/npm:angular:20171018
- id: snykio:npm:angular:2015-03-14
  title: JSONP Callback Attack
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to JSONP Callbacks
    attacks.

    `JSONP` (JSON with padding) is a method used to request data from a
    server residing in a different domain than the client.

    Any url could perform JSONP requests, allowing full access to the
    browser and the JavaScript context. This can lead to Cross-site
    Scripting.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to JSONP Callbacks
    attacks.

    `JSONP` (JSON with padding) is a method used to request data from a
    server residing in a different domain than the client.

    Any url could perform JSONP requests, allowing full access to the
    browser and the JavaScript context. This can lead to Cross-site
    Scripting.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to JSONP Callbacks
    attacks.

    `JSONP` (JSON with padding) is a method used to request data from a
    server residing in a different domain than the client.

    Any url could perform JSONP requests, allowing full access to the
    browser and the JavaScript context. This can lead to Cross-site
    Scripting.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to JSONP Callbacks
    attacks.

    `JSONP` (JSON with padding) is a method used to request data from a
    server residing in a different domain than the client.

    Any url could perform JSONP requests, allowing full access to the
    browser and the JavaScript context. This can lead to Cross-site
    Scripting.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to JSONP Callbacks
    attacks.

    `JSONP` (JSON with padding) is a method used to request data from a
    server residing in a different domain than the client.

    Any url could perform JSONP requests, allowing full access to the
    browser and the JavaScript context. This can lead to Cross-site
    Scripting.



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.6.1"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Pete Bacon Darwin
  references:
  - https://github.com/angular/angular.js/issues/11328
  - https://github.com/angular/angular.js/pull/15161
  - https://github.com/angular/angular.js/pull/15143
  source_url: https://snyk.io/vuln/npm:angular:20150315
- id: snykio:npm:angular:2016-10-31
  title: Content Security Policy (CSP) Bypass
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to CSP Bypass. Extension
    URIs (`resource://...`) bypass Content-Security-Policy in Chrome and
    Firefox and can always be loaded. Now if a site already has a XSS bug,
    and uses CSP to protect itself, but the user has an extension installed
    that uses Angular, an attacker can load Angular from the extension, and
    Angular\'s auto-bootstrapping can be used to bypass the victim site\'s
    CSP protection.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to CSP Bypass. Extension
    URIs (`resource://...`) bypass Content-Security-Policy in Chrome and
    Firefox and can always be loaded. Now if a site already has a XSS bug,
    and uses CSP to protect itself, but the user has an extension installed
    that uses Angular, an attacker can load Angular from the extension, and
    Angular\'s auto-bootstrapping can be used to bypass the victim site\'s
    CSP protection.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to CSP Bypass. Extension
    URIs (`resource://...`) bypass Content-Security-Policy in Chrome and
    Firefox and can always be loaded. Now if a site already has a XSS bug,
    and uses CSP to protect itself, but the user has an extension installed
    that uses Angular, an attacker can load Angular from the extension, and
    Angular\'s auto-bootstrapping can be used to bypass the victim site\'s
    CSP protection.



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.5.9 >=1.5.0"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-284
  credit:
  - Martin Probst
  references:
  - https://github.com/angular/angular.js/pull/15346
  - https://github.com/angular/angular.js/commit/0ff10e1b56c6b7c4ac465e35c96a5886e294bac5
  source_url: https://snyk.io/vuln/npm:angular:20161101
- id: snykio:npm:angular:2016-05-26
  title: Arbitrary Script Injection
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Script Injection.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Script Injection.



    [1]: https://www.npmjs.com/package/angular
    \n`link[href]` attributes were not protected via `$sce`, which prevents
    interpolated values that fail the `RESOURCE_URL` context tests from
    being used in interpolation. For example if the application is running
    at `https://docs.angularjs.org` then the following will fail:

        <link href="{{ 'http://mydomain.org/unsafe.css' }}" rel="stylesheet">

    By default, `RESOURCE_URL` safe URLs are only allowed from the same
    domain and protocol as the application document.

    \n`link[href]` attributes were not protected via `$sce`, which prevents
    interpolated values that fail the `RESOURCE_URL` context tests from
    being used in interpolation. For example if the application is running
    at `https://docs.angularjs.org` then the following will fail:

        <link href="{{ 'http://mydomain.org/unsafe.css' }}" rel="stylesheet">

    By default, `RESOURCE_URL` safe URLs are only allowed from the same
    domain and protocol as the application document.

    \n`link[href]` attributes were not protected via `$sce`, which prevents
    interpolated values that fail the `RESOURCE_URL` context tests from
    being used in interpolation. For example if the application is running
    at `https://docs.angularjs.org` then the following will fail:

        <link href="{{ 'http://mydomain.org/unsafe.css' }}" rel="stylesheet">

    By default, `RESOURCE_URL` safe URLs are only allowed from the same
    domain and protocol as the application document.

    \n`link[href]` attributes were not protected via `$sce`, which prevents
    interpolated values that fail the `RESOURCE_URL` context tests from
    being used in interpolation. For example if the application is running
    at `https://docs.angularjs.org` then the following will fail:

        <link href="{{ 'http://mydomain.org/unsafe.css' }}" rel="stylesheet">

    By default, `RESOURCE_URL` safe URLs are only allowed from the same
    domain and protocol as the application document.

  affected_package: angular
  vulnerable_versions:
  - "<1.2.30 >=1.0.0"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-94
  credit:
  - Raphaël Jamet
  references:
  - https://github.com/angular/angular.js/blob/master/CHANGELOG.md#1230-patronal-resurrection-2016-07-21
  - https://github.com/angular/angular.js/pull/14687
  - https://github.com/angular/angular.js/commit/f35f334bd3197585bdf034f4b6d9ffa3122dac62
  source_url: https://snyk.io/vuln/npm:angular:20160527
- id: snykio:npm:angular:2016-01-21
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS) due
    to the `usemap` attribute not being blacklisted.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS) due
    to the `usemap` attribute not being blacklisted.



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-rc.2 >=1.3.0"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Lucas Mirelmann
  references:
  - https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc2-controller-requisition-2016-01-28
  - https://github.com/angular/angular.js/pull/13826
  - https://github.com/angular/angular.js/commit/234053fc9ad90e0d05be7e8359c6af66be94c094
  source_url: https://snyk.io/vuln/npm:angular:20160122
- id: snykio:npm:angular:2015-12-04
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) via the SVG `<use>` element. The `<use>` element can reference
    external SVG\'s (same origin) and can include `xlink:href` javascript
    urls or foreign object that can execute XSS. The change disallows
    `<use>` elements in sanitized SVG markup.

    An example of a malicious SVG document would be:

    SVG to sanitize:

        <svg><use xlink:href="test.svg#xss" /></svg>

    External SVG file (test.svg):

        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <svg xmlns:svg="http://www.w3.org/2000/svg"
           xmlns="http://www.w3.org/2000/svg" width="100"
           height="100"
           id="xss">
        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)">
          <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
        </a>
        </svg>

    Here the SVG to sanitize loads in the `test.svg` file via the `<use>`
    element. The sanitizer is not able to parse this file, which contains
    malicious executable mark-up. This can only be taken advantage of if the
    external file is available via the same origin restrictions in place.



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-rc.0"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Pete Bacon Darwin
  references:
  - https://github.com/angular/angular.js/pull/13453
  - https://github.com/angular/angular.js/commit/7a668cdd7d08a7016883eb3c671cbcd586223ae8
  source_url: https://snyk.io/vuln/npm:angular:20151205
- id: snykio:npm:angular:2015-11-29
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS)
    attacks involving assignment on `constructor` properties.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS)
    attacks involving assignment on `constructor` properties.



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.4.10"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Lucas Mirelmann
  references:
  - https://github.com/angular/angular.js/pull/13417
  - https://github.com/angular/angular.js/commit/5a674f3bb9d1118d11b333e3b966c01a571c09e6
  source_url: https://snyk.io/vuln/npm:angular:20151130
- id: snykio:npm:angular:2015-09-08
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Mutation Cross-site
    Scripting (mXSS). This error occurs when `$sanitize` sanitizer tries to
    check the input for possible mXSS payload and the verification errors
    due to the input mutating indefinitely. This could be a sign that the
    payload contains code exploiting an mXSS vulnerability in the browser.

    mXSS attack exploit browser bugs that cause some browsers parse a
    certain html strings into DOM, which once serialized doesn\'t match the
    original input. These browser bugs can be exploited by attackers to
    create payload which looks harmless to sanitizers, but due to mutations
    caused by the browser are turned into dangerous code once processed
    after sanitization.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Mutation Cross-site
    Scripting (mXSS). This error occurs when `$sanitize` sanitizer tries to
    check the input for possible mXSS payload and the verification errors
    due to the input mutating indefinitely. This could be a sign that the
    payload contains code exploiting an mXSS vulnerability in the browser.

    mXSS attack exploit browser bugs that cause some browsers parse a
    certain html strings into DOM, which once serialized doesn\'t match the
    original input. These browser bugs can be exploited by attackers to
    create payload which looks harmless to sanitizers, but due to mutations
    caused by the browser are turned into dangerous code once processed
    after sanitization.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Mutation Cross-site
    Scripting (mXSS). This error occurs when `$sanitize` sanitizer tries to
    check the input for possible mXSS payload and the verification errors
    due to the input mutating indefinitely. This could be a sign that the
    payload contains code exploiting an mXSS vulnerability in the browser.

    mXSS attack exploit browser bugs that cause some browsers parse a
    certain html strings into DOM, which once serialized doesn\'t match the
    original input. These browser bugs can be exploited by attackers to
    create payload which looks harmless to sanitizers, but due to mutations
    caused by the browser are turned into dangerous code once processed
    after sanitization.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Mutation Cross-site
    Scripting (mXSS). This error occurs when `$sanitize` sanitizer tries to
    check the input for possible mXSS payload and the verification errors
    due to the input mutating indefinitely. This could be a sign that the
    payload contains code exploiting an mXSS vulnerability in the browser.

    mXSS attack exploit browser bugs that cause some browsers parse a
    certain html strings into DOM, which once serialized doesn\'t match the
    original input. These browser bugs can be exploited by attackers to
    create payload which looks harmless to sanitizers, but due to mutations
    caused by the browser are turned into dangerous code once processed
    after sanitization.



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-beta.2"
  severity: high
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Igor Minar
  references:
  - https://github.com/angular/angular.js/pull/12524
  - https://github.com/angular/angular.js/commit/bc0d8c4eea9a34bff5e29dd492dcdd668251be40
  source_url: https://snyk.io/vuln/npm:angular:20150909
- id: snykio:npm:angular:2015-08-06
  title: Clickjacking
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Clickjacking. By
    enabling the SVG setting without taking other precautions, you might
    expose your application to click-hijacking attacks. In these attacks,
    sanitized SVG elements could be positioned outside of the containing
    element and be rendered over other elements on the page (e.g. a login
    link). Such behavior can then result in phishing incidents.

    To protect against these, explicitly setup `overflow: hidden` css rule
    for all potential SVG tags within the sanitized content:

        .rootOfTheIncludedContent svg {
          overflow: hidden !important;
        }



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Clickjacking. By
    enabling the SVG setting without taking other precautions, you might
    expose your application to click-hijacking attacks. In these attacks,
    sanitized SVG elements could be positioned outside of the containing
    element and be rendered over other elements on the page (e.g. a login
    link). Such behavior can then result in phishing incidents.

    To protect against these, explicitly setup `overflow: hidden` css rule
    for all potential SVG tags within the sanitized content:

        .rootOfTheIncludedContent svg {
          overflow: hidden !important;
        }



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Clickjacking. By
    enabling the SVG setting without taking other precautions, you might
    expose your application to click-hijacking attacks. In these attacks,
    sanitized SVG elements could be positioned outside of the containing
    element and be rendered over other elements on the page (e.g. a login
    link). Such behavior can then result in phishing incidents.

    To protect against these, explicitly setup `overflow: hidden` css rule
    for all potential SVG tags within the sanitized content:

        .rootOfTheIncludedContent svg {
          overflow: hidden !important;
        }



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Clickjacking. By
    enabling the SVG setting without taking other precautions, you might
    expose your application to click-hijacking attacks. In these attacks,
    sanitized SVG elements could be positioned outside of the containing
    element and be rendered over other elements on the page (e.g. a login
    link). Such behavior can then result in phishing incidents.

    To protect against these, explicitly setup `overflow: hidden` css rule
    for all potential SVG tags within the sanitized content:

        .rootOfTheIncludedContent svg {
          overflow: hidden !important;
        }



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Clickjacking. By
    enabling the SVG setting without taking other precautions, you might
    expose your application to click-hijacking attacks. In these attacks,
    sanitized SVG elements could be positioned outside of the containing
    element and be rendered over other elements on the page (e.g. a login
    link). Such behavior can then result in phishing incidents.

    To protect against these, explicitly setup `overflow: hidden` css rule
    for all potential SVG tags within the sanitized content:

        .rootOfTheIncludedContent svg {
          overflow: hidden !important;
        }



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-beta.0 >=1.3.1"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-693
  credit:
  - Igor Minar
  references:
  - https://github.com/angular/angular.js/pull/12524
  - https://github.com/angular/angular.js/commit/181fc567d873df065f1e84af7225deb70a8d2eb9
  source_url: https://snyk.io/vuln/npm:angular:20150807-1
- id: snykio:npm:angular:2015-08-06
  title: Cross-site Scripting (XSS)
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS) due
    to no proper sanitization of `xlink:href` attributes.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS) due
    to no proper sanitization of `xlink:href` attributes.



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-beta.0 >=1.0.0"
  severity: high
  package_manager: npm
  cwe:
  - CWE-78
  credit:
  - Igor Minar
  references:
  - https://github.com/angular/angular.js/pull/12524
  - https://github.com/angular/angular.js/commit/f33ce173c90736e349cf594df717ae3ee41e0f7a
  source_url: https://snyk.io/vuln/npm:angular:20150807
- id: snykio:npm:angular:2015-03-09
  title: Arbitrary Code Execution
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Code Execution via
    unsafe svg animation tags.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Code Execution via
    unsafe svg animation tags.



    [1]: https://www.npmjs.com/package/angular
    \nExploit Example:

        <svg>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="?">
            <circle r="400"></circle>
            <animate attributeName="xlink:href" begin="0" from="javascript:alert(1)" to="&" />
          </a>
        </svg>

    Here the anchor\'s href is animated, starting from a value that\'s a
    javascript URI. This allows execution of arbitrary javascript in the
    process. Preventing only the animation of links is tricky, as SVG is
    weird and namespaces aren\'t predictable. The fix is to have the
    sanitizer filter out svg animation tags instead.

    \nExploit Example:

        <svg>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="?">
            <circle r="400"></circle>
            <animate attributeName="xlink:href" begin="0" from="javascript:alert(1)" to="&" />
          </a>
        </svg>

    Here the anchor\'s href is animated, starting from a value that\'s a
    javascript URI. This allows execution of arbitrary javascript in the
    process. Preventing only the animation of links is tricky, as SVG is
    weird and namespaces aren\'t predictable. The fix is to have the
    sanitizer filter out svg animation tags instead.

    \nExploit Example:

        <svg>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="?">
            <circle r="400"></circle>
            <animate attributeName="xlink:href" begin="0" from="javascript:alert(1)" to="&" />
          </a>
        </svg>

    Here the anchor\'s href is animated, starting from a value that\'s a
    javascript URI. This allows execution of arbitrary javascript in the
    process. Preventing only the animation of links is tricky, as SVG is
    weird and namespaces aren\'t predictable. The fix is to have the
    sanitizer filter out svg animation tags instead.

    \nExploit Example:

        <svg>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="?">
            <circle r="400"></circle>
            <animate attributeName="xlink:href" begin="0" from="javascript:alert(1)" to="&" />
          </a>
        </svg>

    Here the anchor\'s href is animated, starting from a value that\'s a
    javascript URI. This allows execution of arbitrary javascript in the
    process. Preventing only the animation of links is tricky, as SVG is
    weird and namespaces aren\'t predictable. The fix is to have the
    sanitizer filter out svg animation tags instead.

  affected_package: angular
  vulnerable_versions:
  - "<1.5.0-beta.2"
  severity: high
  package_manager: npm
  cwe:
  - CWE-78
  credit:
  - Rodric Haddad
  references:
  - https://github.com/angular/angular.js/pull/11290
  - https://github.com/angular/angular.js/commit/67688d5ca00f6de4c7fe6084e2fa762a00d25610
  source_url: https://snyk.io/vuln/npm:angular:20150310
- id: snykio:npm:angular:2014-11-03
  title: Arbitrary Command Execution
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Command Injection
    due to the assignment functions accessing constructors functions,
    allowing attackers to execute their malicious code.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Command Injection
    due to the assignment functions accessing constructors functions,
    allowing attackers to execute their malicious code.



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.3.2"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-78
  credit:
  - Sebastian Lekies
  - Jann Horn
  - Gábor Molnár
  references:
  - https://github.com/angular/angular.js/commit/e676d642f5feb8d3ba88944634afb479ba525c36
  - https://github.com/angular/angular.js/blob/master/CHANGELOG.md#132-cardiovasculatory-magnification-2014-11-07
  source_url: https://snyk.io/vuln/npm:angular:20141104
- id: snykio:npm:angular:2014-09-08
  title: Unsafe Object Deserialization
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Unsafe Object Deserialization.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Unsafe Object Deserialization.



    [1]: https://www.npmjs.com/package/angular
    \nThe exploitable code:

        hasOwnProperty.constructor.prototype.valueOf = valueOf.call;
            ["a", "alert(1)"].sort(hasOwnProperty.constructor);

    The exploit:

    * 1.  `Array.sort` takes a comparison function and passes it 2
          parameters to compare.
      2.  It then calls `.valueOf()` if the result is not a primitive.

    * The `Function` object conveniently accepts two string arguments so so
      it can be used to construct a function. However, this doesn\'t do much
      unless it can be executed.
    * The `valueOf` function on `Function.prototype` was set to
      `Function.prototype.call`. This causes the function constructed to be
      executed when sort calls `.valueOf()` on the result of the comparison.

    \nThe exploitable code:

        hasOwnProperty.constructor.prototype.valueOf = valueOf.call;
            ["a", "alert(1)"].sort(hasOwnProperty.constructor);

    The exploit:

    * 1.  `Array.sort` takes a comparison function and passes it 2
          parameters to compare.
      2.  It then calls `.valueOf()` if the result is not a primitive.

    * The `Function` object conveniently accepts two string arguments so so
      it can be used to construct a function. However, this doesn\'t do much
      unless it can be executed.
    * The `valueOf` function on `Function.prototype` was set to
      `Function.prototype.call`. This causes the function constructed to be
      executed when sort calls `.valueOf()` on the result of the comparison.

    \nThe exploitable code:

        hasOwnProperty.constructor.prototype.valueOf = valueOf.call;
            ["a", "alert(1)"].sort(hasOwnProperty.constructor);

    The exploit:

    * 1.  `Array.sort` takes a comparison function and passes it 2
          parameters to compare.
      2.  It then calls `.valueOf()` if the result is not a primitive.

    * The `Function` object conveniently accepts two string arguments so so
      it can be used to construct a function. However, this doesn\'t do much
      unless it can be executed.
    * The `valueOf` function on `Function.prototype` was set to
      `Function.prototype.call`. This causes the function constructed to be
      executed when sort calls `.valueOf()` on the result of the comparison.

    \nThe exploitable code:

        hasOwnProperty.constructor.prototype.valueOf = valueOf.call;
            ["a", "alert(1)"].sort(hasOwnProperty.constructor);

    The exploit:

    * 1.  `Array.sort` takes a comparison function and passes it 2
          parameters to compare.
      2.  It then calls `.valueOf()` if the result is not a primitive.

    * The `Function` object conveniently accepts two string arguments so so
      it can be used to construct a function. However, this doesn\'t do much
      unless it can be executed.
    * The `valueOf` function on `Function.prototype` was set to
      `Function.prototype.call`. This causes the function constructed to be
      executed when sort calls `.valueOf()` on the result of the comparison.

    \nThe exploitable code:

        hasOwnProperty.constructor.prototype.valueOf = valueOf.call;
            ["a", "alert(1)"].sort(hasOwnProperty.constructor);

    The exploit:

    * 1.  `Array.sort` takes a comparison function and passes it 2
          parameters to compare.
      2.  It then calls `.valueOf()` if the result is not a primitive.

    * The `Function` object conveniently accepts two string arguments so so
      it can be used to construct a function. However, this doesn\'t do much
      unless it can be executed.
    * The `valueOf` function on `Function.prototype` was set to
      `Function.prototype.call`. This causes the function constructed to be
      executed when sort calls `.valueOf()` on the result of the comparison.

  affected_package: angular
  vulnerable_versions:
  - "<1.2.24 >=1.2.19"
  severity: high
  package_manager: npm
  cwe:
  - CWE-502
  credit:
  - Chirayu Krishnappa
  references:
  - https://github.com/angular/angular.js/commit/b39e1d47b9a1b39a9fe34c847a81f589fba522f8
  source_url: https://snyk.io/vuln/npm:angular:20140909
- id: snykio:npm:angular:2014-09-07
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS) due
    to unsanitized URIs in `ng-srcset`.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS) due
    to unsanitized URIs in `ng-srcset`.



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.3.0-rc.4"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Laurent Trillaud
  references:
  - https://github.com/angular/angular.js/pull/8975
  - https://github.com/angular/angular.js/commit/ab80cd90661396dbb1c94c5f4dd2d11ee8f6b6af
  source_url: https://snyk.io/vuln/npm:angular:20140908
- id: snykio:npm:angular:2014-06-07
  title: Arbitrary Code Execution
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Code Execution.
    `$parse` allowed arbitrary code execution via Angular expressions under
    some very specific conditions. The only applications affected by these
    vulnerabilities are those that match all of the following conditions:

    * Application mixes server-side and client-side templating
    * The server-side templating contains XSS vulnerabilities
    * The vulnerabilities in the server-side templating are being guarded by
      server-side XSS filters or on the client-side via CSP
    * The server-side XSS vulnerabilities can be used to augment the
      client-side template processed by Angular **Applications not meeting
      all of the conditions are not vulnerable.**



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Code Execution.
    `$parse` allowed arbitrary code execution via Angular expressions under
    some very specific conditions. The only applications affected by these
    vulnerabilities are those that match all of the following conditions:

    * Application mixes server-side and client-side templating
    * The server-side templating contains XSS vulnerabilities
    * The vulnerabilities in the server-side templating are being guarded by
      server-side XSS filters or on the client-side via CSP
    * The server-side XSS vulnerabilities can be used to augment the
      client-side template processed by Angular **Applications not meeting
      all of the conditions are not vulnerable.**



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Code Execution.
    `$parse` allowed arbitrary code execution via Angular expressions under
    some very specific conditions. The only applications affected by these
    vulnerabilities are those that match all of the following conditions:

    * Application mixes server-side and client-side templating
    * The server-side templating contains XSS vulnerabilities
    * The vulnerabilities in the server-side templating are being guarded by
      server-side XSS filters or on the client-side via CSP
    * The server-side XSS vulnerabilities can be used to augment the
      client-side template processed by Angular **Applications not meeting
      all of the conditions are not vulnerable.**



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.3.0"
  severity: low
  package_manager: npm
  cwe:
  - CWE-94
  credit:
  - Jann Horn
  references:
  - https://github.com/angular/angular.js/blob/b3b5015cb7919708ce179dc3d6f0d7d7f43ef621/CHANGELOG.md#130-beta14-harmonious-cacophonies-2014-06-30
  - https://github.com/angular/angular.js/commit/528be29d1662122a34e204dd607e1c0bd9c16bbc
  - https://github.com/angular/angular.js/commit/48fa3aadd546036c7e69f71046f659ab1de244c6
  - https://github.com/angular/angular.js/commit/77ada4c82d6b8fc6d977c26f3cdb48c2f5fbe5a5
  source_url: https://snyk.io/vuln/npm:angular:20140608
- id: snykio:npm:angular:2013-11-12
  title: Protection Bypass
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Protection Bypass via
    `ng-attr-action` and `ng-attr-srcdoc` allowing binding to Javascript.
    The fix was to require bindings to `form[action]` to be
    `$sce.RESOURCE_URL` and bindings to `iframe[srcdoc]` to be `$sce.HTML`



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Protection Bypass via
    `ng-attr-action` and `ng-attr-srcdoc` allowing binding to Javascript.
    The fix was to require bindings to `form[action]` to be
    `$sce.RESOURCE_URL` and bindings to `iframe[srcdoc]` to be `$sce.HTML`



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.2.2"
  severity: high
  package_manager: npm
  cwe:
  - CWE-284
  credit:
  - Chirayu Krishnappa
  references:
  - https://code.google.com/archive/p/mustache-security/wikis/AngularJS.wiki#The_State_of_AngularJS_1.2.x
  - https://github.com/angular/angular.js/pull/4933
  - https://github.com/angular/angular.js/issues/4927
  source_url: https://snyk.io/vuln/npm:angular:20131113
- id: snykio:npm:angular:2013-06-24
  title: Arbitrary Script Injection
  description: |
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Script Injection due
    to improper sanitization of the `$event` object passed to the native
    constructor functions. That isn\'t protected by the fast paths in
    `$parse`.



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Arbitrary Script Injection due
    to improper sanitization of the `$event` object passed to the native
    constructor functions. That isn\'t protected by the fast paths in
    `$parse`.



    [1]: https://www.npmjs.com/package/angular
  affected_package: angular
  vulnerable_versions:
  - "<1.1.5"
  severity: high
  package_manager: npm
  cwe:
  - CWE-78
  credit:
  - Chirayu Krishnappa
  - Igor Minar
  source_url: https://snyk.io/vuln/npm:angular:20130625
- id: snykio:npm:angular:2013-06-21
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability. Affected
    versions of the package are vulnerable to Cross-site Scripting (XSS).

    Concatenating expressions makes it hard to reason about whether some
    combination of concatenated values are unsafe to use and could easily
    lead to XSS. By requiring that a single expression be used for
    `*[src/ng-src]` such as `iframe[src]`, `object[src]`, etc. (but not
    `img[src/ng-src]` since that value is sanitized), it is ensured that the
    value that\'s used is assigned or constructed by some JS code somewhere
    that is more testable or make it obvious that you bound the value to
    some user controlled value. This helps reduce the load when auditing for
    XSS issues.

    To migrate your code, follow the example below:

    Before:

        JS:
        scope.baseUrl = 'page';
        scope.a = 1;
        scope.b = 2;
    ^

        HTML:
        <!-- Are a and b properly escaped here? Is baseUrl
         controlled by user? -->
        <iframe src="{{baseUrl}}?a={{a}&b={{b}}">

    After:

        JS:
        var baseUrl = "page";
        scope.getIframeSrc = function() {
          // There are obviously better ways to do this.  The
          // key point is that one will think about this and do
          // it the right way.
          var qs = ["a", "b"].map(function(value, name) {
          return encodeURIComponent(name) + "=" +
         encodeURIComponent(value);
        }).join("&");
          // baseUrl isn't on scope so it isn't bound to a user
          // controlled value.
          return baseUrl + "?" + qs;
        }
    ^

        HTML: <iframe src="{{getIframeSrc()}}">Before:



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<1.2.0 >=1.0.0"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-79
  credit:
  - Chirayu Krishnappa
  references:
  - https://github.com/angular/angular.js/pull/3030
  - https://github.com/angular/angular.js/commit/38deedd6e3d806eb8262bb43f26d47245f6c2739
  source_url: https://snyk.io/vuln/npm:angular:20130622
- id: snykio:npm:angular:2013-06-20
  title: Cross-site Scripting (XSS)
  description: |+
    [`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \n[`angular`][1] is an open-source JavaScript framework, maintained by
    Google, that assists with running single-page applications with the goal
    of making development and testing easier by augmenting browser-based
    applications with model–view–controller (MVC) capability.

    Affected versions of the package are vulnerable to Cross-site Scripting
    (XSS) attacks.

    DOM event handlers await events to occur (e.g. onclick, onkeypress, etc)
    and execute arbitrary Javascript code in accordance to the event. By
    default, interpolations inside DOM event handlers are disallowed. Using
    an interpolation for such handlers means that the interpolated value is
    a JS string being evaluated. Storing or generating such strings is error
    prone and likely leads to a Cross-site Scripting (XSS) vulnerability if
    you\'re not careful. On the other hand, ng-click and such event handlers
    evaluate Angular expressions that are a lot safer (e.g. No direct access
    to global objects - only scope), cleaner and harder to exploit.

    To migrate the code follow the example below: Before:

        JS:   scope.foo = 'alert(1)';
    ^

        HTML: <div onclick="{{foo}}">

    After:

        JS:   scope.foo = function() { alert(1); }
    ^

        HTML: <div ng-click="foo()">



    [1]: https://www.npmjs.com/package/angular
    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

    \nCross-Site Scripting (XSS) attacks occur when an attacker tricks a
    user’s browser to execute malicious JavaScript code in the context of a
    victim’s domain. Such scripts can steal the user’s session cookies for
    the domain, scrape or modify its content, and perform or modify actions
    on the user’s behalf, actions typically blocked by the browser’s Same
    Origin Policy.

    These attacks are possible by escaping the context of the web
    application and injecting malicious scripts in an otherwise trusted
    website. These scripts can introduce additional attributes (say, a
    \"new\" option in a dropdown list or a new link to a malicious site) and
    can potentially execute code on the clients side, unbeknown to the
    victim. This occurs when characters like `<` `>` `"` `'` are not escaped
    properly.

    There are a few types of XSS:

    * **Persistent XSS** is an attack in which the malicious code persists
      into the web app’s database.
    * **Reflected XSS** is an which the website echoes back a portion of the
      request. The attacker needs to trick the user into clicking a
      malicious link (for instance through a phishing email or malicious JS
      on another page), which triggers the XSS attack.
    * **DOM-based XSS** is an that occurs purely in the browser when
      client-side JavaScript echoes back a portion of the URL onto the page.
      DOM-Based XSS is notoriously hard to detect, as the server never gets
      a chance to see the attack taking place.

  affected_package: angular
  vulnerable_versions:
  - "<=1.1.5"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-78
  credit:
  - Chirayu Krishnappa
  references:
  - https://github.com/angular/angular.js/commit/39841f2ec9b17b3b2920fd1eb548d444251f4f56
  source_url: https://snyk.io/vuln/npm:angular:20130621
