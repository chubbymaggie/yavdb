---
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-01-06
  title: "[CVE-2016-9879] An issue was discovered in Pivotal Spring Security before
    3.2.10, 4.1.x before 4..."
  description: An issue was discovered in Pivotal Spring Security before 3.2.10, 4.1.x
    before 4.1.4, and 4.2.x before 4.2.1. Spring Security does not consider URL path
    parameters when processing security constraints. By adding a URL path parameter
    with an encoded "/" to a request, an attacker may be able to bypass a security
    constraint. The root cause of this issue is a lack of clarity regarding the handling
    of path parameters in the Servlet Specification. Some Servlet containers include
    path parameters in the value returned for getPathInfo() and some do not. Spring
    Security uses the value returned by getPathInfo() as part of the process of mapping
    requests to security constraints. The unexpected presence of path parameters can
    cause a constraint to be bypassed. Users of Apache Tomcat (all current versions)
    are not affected by this vulnerability since Tomcat follows the guidance previously
    provided by the Servlet Expert group and strips path parameters from the value
    returned by getContextPath(), getServletPath(), and getPathInfo(). Users of other
    Servlet containers based on Apache Tomcat may or may not be affected depending
    on whether or not the handling of path parameters has been modified. Users of
    IBM WebSphere Application Server 8.5.x are known to be affected. Users of other
    containers that implement the Servlet specification may be affected.
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - 3.2.0
  - 3.2.1
  - 3.2.2
  - 3.2.3
  - 3.2.4
  - 3.2.5
  - 3.2.6
  - 3.2.7
  - 3.2.8
  - 3.2.9
  - 4.1.0
  - 4.1.1
  - 4.1.2
  - 4.1.3
  - 4.2.0
  package_manager: maven
  cve:
  - CVE-2016-9879
  credit:
  - OSSIndex
  references:
  - http://www.securityfocus.com/bid/95142
  - https://access.redhat.com/errata/RHSA-2017:1832
  - https://pivotal.io/security/cve-2016-9879
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-01-30
  title: Cross Site Scripting in sample apps
  description: There is an exploitable XSS in some provided sample applications.
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "<1.0.4"
  package_manager: maven
  credit:
  - OSSIndex
  references:
  - https://cwe.mitre.org/data/definitions/79.html
  - https://github.com/SpringSource/spring-security/issues/709
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-01-30
  title: "[Unconfirmed] Possible Cross-site request forgery (CSRF) in SwitchUserFilter"
  description: "> It seems the `SwitchUserFilter` responds to all HTTP methods, making
    it vulnerable to CSRF attacks. \n> \n> -- [github.com](https://github.com/spring-projects/spring-security/issues/4183)"
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">=3.2"
  package_manager: maven
  credit:
  - OSSIndex
  references:
  - https://github.com/spring-projects/spring-security/issues/4183
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-01-30
  title: BREACH attack possible in CSRF tokens
  description: "> The CSRF tokens generated by Spring are vulnerable to a BREACH attack.\n>
    \n> ...\n> \n> This only occurs when you turn on CSRF protection in Spring and
    also have HTTP compression enabled somewhere in your web server stack.\n> \n>
    -- [github.com](https://github.com/spring-projects/spring-security/issues/4001)"
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "<5.0.0"
  package_manager: maven
  credit:
  - OSSIndex
  references:
  - http://breachattack.com
  - https://github.com/spring-projects/spring-security/issues/4001
  - https://github.com/spring-projects/spring-security/pull/4042
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-02-12
  title: "[CVE-2012-5055] DaoAuthenticationProvider can reveal which usernames are
    valid"
  description: "> Spring Security's DaoAuthenticationProvider authenticates users
    by utilizing the PasswordEncoder interface to compare the submitted password with
    the actual password. If a user is not found, the comparison is skipped which,
    depending on the PasswordEncoder implementation, can result in a significant difference
    in the amount of time required to attempt to authenticate an actual user versus
    a user that does not exist. This opens up the possibility of a side channel attack
    that would enable a malicious user to determine if a username is valid.\n> \n>
    -- [jira.spring.io](https://jira.spring.io/browse/SEC-2056)"
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">=2.0.0 <2.0.8"
  - ">=3.0.0.RELEASE <3.0.8"
  - ">=3.1.0.RELEASE <3.1.3"
  package_manager: maven
  credit:
  - OSSIndex
  references:
  - https://github.com/spring-projects/spring-security/issues/2280
  - https://github.com/victims/victims-cve-db/blob/master/database/java/2012/5055.yaml
  - https://jira.spring.io/browse/SEC-2056
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-05-25
  title: "[CVE-2016-5007]  Permissions, Privileges, and Access Controls"
  description: Both Spring Security 3.2.x, 4.0.x, 4.1.0 and the Spring Framework 3.2.x,
    4.0.x, 4.1.x, 4.2.x rely on URL pattern mappings for authorization and for mapping
    requests to controllers respectively. Differences in the strictness of the pattern
    matching mechanisms, for example with regards to space trimming in path segments,
    can lead Spring Security to not recognize certain paths as not protected that
    are in fact mapped to Spring MVC controllers that should be protected. The problem
    is compounded by the fact that the Spring Framework provides richer features with
    regards to pattern matching as well as by the fact that pattern matching in each
    Spring Security and the Spring Framework can easily be customized creating additional
    differences.
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - 3.2.0
  - 3.2.1
  - 3.2.10
  - 3.2.2
  - 3.2.3
  - 3.2.4
  - 3.2.5
  - 3.2.6
  - 3.2.7
  - 3.2.8
  - 3.2.9
  - 4.0.0
  - 4.0.1
  - 4.0.2
  - 4.0.3
  - 4.0.4
  - 4.1.0
  package_manager: maven
  cve:
  - CVE-2016-5007
  credit:
  - OSSIndex
  references:
  - http://www.securityfocus.com/bid/91687
  - https://pivotal.io/security/cve-2016-5007
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-05-25
  title: "[CVE-2014-3527]  Improper Authentication"
  description: When using the CAS Proxy ticket authentication from Spring Security
    3.1 to 3.2.4 a malicious CAS Service could trick another CAS Service into authenticating
    a proxy ticket that was not associated. This is due to the fact that the proxy
    ticket authentication uses the information from the HttpServletRequest which is
    populated based upon untrusted information within the HTTP request. This means
    if there are access control restrictions on which CAS services can authenticate
    to one another, those restrictions can be bypassed. If users are not using CAS
    Proxy tickets and not basing access control decisions based upon the CAS Service,
    then there is no impact to users.
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - 3.1.0
  - 3.1.1
  - 3.1.2
  - 3.1.3
  - 3.1.4
  - 3.2.0
  - 3.2.1
  - 3.2.2
  - 3.2.3
  - 3.2.4
  package_manager: maven
  cve:
  - CVE-2014-3527
  credit:
  - OSSIndex
  references:
  - https://pivotal.io/security/cve-2014-3527
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: ossindex:maven:org.springframework.security:spring-security-core:2017-05-25
  title: "[CVE-2014-0097]  Improper Authentication"
  description: The ActiveDirectoryLdapAuthenticator in Spring Security 3.2.0 to 3.2.1
    and 3.1.0 to 3.1.5 does not check the password length. If the directory allows
    anonymous binds then it may incorrectly authenticate a user who supplies an empty
    password.
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - 3.1.0
  - 3.1.1
  - 3.1.2
  - 3.1.3
  - 3.1.4
  - 3.1.5
  - 3.2.0
  - 3.2.1
  package_manager: maven
  cve:
  - CVE-2014-0097
  credit:
  - OSSIndex
  references:
  - https://pivotal.io/security/cve-2014-0097
  source_url: https://ossindex.net/resource/package/7015205374/vulnerabilities
- id: snykio:maven:org.springframework.security:spring-security-core:2014-09-08
  title: Improper Authentication
  description: |
    [`org.springframework.security:spring-security-core`][1] Race condition
    in the RunAsManager mechanism in VMware SpringSource Spring Security
    before 2.0.7 and 3.0.x before 3.0.6 stores the Authentication object in
    the shared security context, which allows attackers to gain privileges
    via a crafted thread.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
    \n[`org.springframework.security:spring-security-core`][1] Race condition
    in the RunAsManager mechanism in VMware SpringSource Spring Security
    before 2.0.7 and 3.0.x before 3.0.6 stores the Authentication object in
    the shared security context, which allows attackers to gain privileges
    via a crafted thread.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "< 2.0.7"
  - ">= 3 < 3.0.6"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2011-2731
  cwe:
  - CWE-362
  credit:
  - Unknown
  references:
  - https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-2731
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-31338
- id: snykio:maven:org.springframework.security:spring-security-core:2014-09-08
  title: Arbitrary Code Execution
  description: |
    [`org.springframework.security:spring-security-core`][1] CRLF injection
    vulnerability in the logout functionality in VMware SpringSource Spring
    Security before 2.0.7 and 3.0.x before 3.0.6 allows remote attackers to
    inject arbitrary HTTP headers and conduct HTTP response splitting
    attacks via the spring-security-redirect parameter.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
    \n[`org.springframework.security:spring-security-core`][1] CRLF injection
    vulnerability in the logout functionality in VMware SpringSource Spring
    Security before 2.0.7 and 3.0.x before 3.0.6 allows remote attackers to
    inject arbitrary HTTP headers and conduct HTTP response splitting
    attacks via the spring-security-redirect parameter.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "< 2.0.7"
  - ">= 3 < 3.0.6"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2011-2732
  cwe:
  - CWE-94
  credit:
  - Unknown
  references:
  - https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-2732
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-31339
- id: snykio:maven:org.springframework.security:spring-security-core:2014-09-08
  title: Access Restriction Bypass
  description: |
    [`org.springframework.security:spring-security-core`][1] Spring
    Framework 3.0.0 through 3.0.5, Spring Security 3.0.0 through 3.0.5 and
    2.0.0 through 2.0.6, and possibly other versions deserialize objects
    from untrusted sources, which allows remote attackers to bypass intended
    security restrictions and execute untrusted code by (1) serializing a
    java.lang.Proxy instance and using InvocationHandler, or (2) accessing
    internal AOP interfaces, as demonstrated using deserialization of a
    DefaultListableBeanFactory instance to execute arbitrary commands via
    the java.lang.Runtime class.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
    \n[`org.springframework.security:spring-security-core`][1] Spring
    Framework 3.0.0 through 3.0.5, Spring Security 3.0.0 through 3.0.5 and
    2.0.0 through 2.0.6, and possibly other versions deserialize objects
    from untrusted sources, which allows remote attackers to bypass intended
    security restrictions and execute untrusted code by (1) serializing a
    java.lang.Proxy instance and using InvocationHandler, or (2) accessing
    internal AOP interfaces, as demonstrated using deserialization of a
    DefaultListableBeanFactory instance to execute arbitrary commands via
    the java.lang.Runtime class.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">= 2 < 2.0.7"
  - ">= 3 < 3.0.6"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2011-2894
  cwe:
  - CWE-264
  credit:
  - Unknown
  references:
  - https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-2894
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-31340
- id: snykio:maven:org.springframework.security:spring-security-core:2015-06-10
  title: Access Restriction Bypass
  description: |
    [`org.springframework.security:spring-security-core`][1] VMware
    SpringSource Spring Security 2.x before 2.0.6 and 3.x before 3.0.4, and
    Acegi Security 1.0.0 through 1.0.7, as used in IBM WebSphere Application
    Server (WAS) 6.1 and 7.0, allows remote attackers to bypass security
    constraints via a path parameter.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
    \n[`org.springframework.security:spring-security-core`][1] VMware
    SpringSource Spring Security 2.x before 2.0.6 and 3.x before 3.0.4, and
    Acegi Security 1.0.0 through 1.0.7, as used in IBM WebSphere Application
    Server (WAS) 6.1 and 7.0, allows remote attackers to bypass security
    constraints via a path parameter.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">= 2.0.0 < 2.0.6"
  - ">= 3 < 3.0.4"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2010-3700
  cwe:
  - CWE-264
  credit:
  - Unknown
  references:
  - https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-3700
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-31337
- id: snykio:maven:org.springframework.security:spring-security-core:2016-12-25
  title: Authentication Bypass
  description: |
    [`org.springframework.security:spring-security-core`][1] The
    ActiveDirectoryLdapAuthenticator does not check the password length. If
    the directory allows anonymous binds then it may incorrectly
    authenticate a user who supplies an empty password.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
    \n[`org.springframework.security:spring-security-core`][1] The
    ActiveDirectoryLdapAuthenticator does not check the password length. If
    the directory allows anonymous binds then it may incorrectly
    authenticate a user who supplies an empty password.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">= 3.2 <= 3.2.1.RELEASE"
  - ">= 3.1 <= 3.1.5.RELEASE"
  severity: high
  package_manager: maven
  cve:
  - CVE-2014-0097
  cwe:
  - CWE-592
  credit:
  - Spring Development team
  references:
  - http://www.gopivotal.com/security/cve-2014-0097
  - https://bugzilla.redhat.com/CVE-2014-0097
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-30175
- id: snykio:maven:org.springframework.security:spring-security-core:2016-12-25
  title: Information Exposure
  description: |
    [`org.springframework.security:spring-security-core`][1]
    DaoAuthenticationProvider in VMware SpringSource Spring Security before
    2.0.8, 3.0.x before 3.0.8, and 3.1.x before 3.1.3 does not check the
    password if the user is not found, which makes the response delay
    shorter and might allow remote attackers to enumerate valid usernames
    via a series of login requests.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
    \n[`org.springframework.security:spring-security-core`][1]
    DaoAuthenticationProvider in VMware SpringSource Spring Security before
    2.0.8, 3.0.x before 3.0.8, and 3.1.x before 3.1.3 does not check the
    password if the user is not found, which makes the response delay
    shorter and might allow remote attackers to enumerate valid usernames
    via a series of login requests.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-core%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "< 2.0.8"
  - ">= 3 < 3.0.8"
  - ">= 3.1 < 3.1.3"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2012-5055
  cwe:
  - CWE-200
  credit:
  - Unknown
  references:
  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5055
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-30174
- id: snykio:maven:org.springframework.security:spring-security-core:2016-12-28
  title: Security Bypass
  description: |
    [`org.springframework.security:spring-security-web`][1] It was found
    that Spring Security does not consider URL path parameters when
    processing security constraints. By adding a URL path parameter with an
    encoded / to a request an attacker may be able to bypass a security
    constraint.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-web%22
    \n[`org.springframework.security:spring-security-web`][1] It was found
    that Spring Security does not consider URL path parameters when
    processing security constraints. By adding a URL path parameter with an
    encoded / to a request an attacker may be able to bypass a security
    constraint.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22spring-security-web%22
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">= 3.2.0.RELEASE < 3.2.10.RELEASE"
  - ">= 4.0.0.RELEASE < 4.1.4.RELEASE"
  - ">= 4.2.0.RELEASE < 4.2.1.RELEASE"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2016-9879
  cwe:
  - CWE-417
  credit:
  - Shumpei Asahara
  - Yuji Ito
  references:
  - https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-9879
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-31612
- id: snykio:maven:org.springframework.security:spring-security-core:2017-06-08
  title: Deserialization of Untrusted Data
  description: "Affected versions of\n[`org.springframework.security:spring-security-core`][1]
    are vulnerable\nto Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core`
    configures `Jackson` with the global `default\ntyping` enabled. Although `Jackson`
    blacklisted known `deserialization\ngadgets`, it is still possible for a malicious
    user to execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n\\nAffected
    versions of\n[`org.springframework.security:spring-security-core`][1] are vulnerable\nto
    Deserialization of Untrusted Data, via `Jackson`.\n\n`spring-security-core` configures
    `Jackson` with the global `default\ntyping` enabled. Although `Jackson` blacklisted
    known `deserialization\ngadgets`, it is still possible for a malicious user to
    execute arbitrary\ncode on the following conditions:\n\n1.  Spring Security’s
    Jackson support is being leveraged by invoking\n    SecurityJackson2Modules.getModules(ClassLoader)
    or\n    SecurityJackson2Modules.enableDefaultTyping(ObjectMapper)\n2.  Jackson
    is used to deserialize data that is not trusted. Spring\n    Security does not
    perform deserialization using Jackson, so this is\n    an explicit choice of the
    user.\n3.  There is an unknown (Jackson is not blacklisting it already)\n    “deserialization
    gadget” that allows code execution present on the\n    classpath\n\nThis is related
    to [SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507][2].\n\n# Details   {#details}\n\nSerialization
    is a process of converting an object into a sequence of\nbytes which can be persisted
    to a disk or database or can be sent\nthrough streams. The reverse process of
    creating object from sequence of\nbytes is called deserialization. Serialization
    is commonly used for\ncommunication (sharing objects between multiple hosts) and
    persistence\n(store the object state in a file or a database). It is an integral
    part\nof popular protocols like *Remote Method Invocation (RMI)*, *Java\nManagement
    Extension (JMX)*, *Java Messaging System (JMS)*, *Action\nMessage Format (AMF)*,
    *Java Server Faces (JSF) ViewState*, etc.\n\n*Deserialization of untrusted data*
    ([CWE-502][3]), is when the\napplication deserializes untrusted data without sufficiently
    verifying\nthat the resulting data will be valid, letting the attacker to control\nthe
    state or the flow of the execution.\n\nJava deserialization issues have been known
    for years. However, interest\nin the issue intensified greatly in 2015, when classes
    that could be\nabused to achieve remote code execution were found in a [popular
    library\n(Apache Commons Collection)][4]. These classes were used in zero-days\naffecting
    IBM WebSphere, Oracle WebLogic and many other products.\n\nAn attacker just needs
    to identify a piece of software that has both a\nvulnerable class on its path,
    and performs deserialization on untrusted\ndata. Then all they need to do is send
    the payload into the\ndeserializer, getting the command executed.\n\n> Developers
    put too much trust in Java Object Serialization. Some even\n> de-serialize objects
    pre-authentication. When deserializing an Object\n> in Java you typically cast
    it to an expected type, and therefore\n> Java\\'s strict type system will ensure
    you only get valid object\n> trees. Unfortunately, by the time the type checking
    happens, platform\n> code has already created and executed significant logic.
    So, before\n> the final type is checked a lot of code is executed from the\n>
    readObject() methods of various objects, all of which is out of the\n> developer\\'s
    control. By combining the readObject() methods of various\n> classes which are
    available on the classpath of the vulnerable\n> application an attacker can execute
    functions (including calling\n> Runtime.exec() to execute local OS commands).\n>
    \n> * Apache Blog\n\nThe vulnerability, also know as *Mad Gadget*\n\n> Mad Gadget
    is one of the most pernicious vulnerabilities we’ve seen.\n> By merely existing
    on the Java classpath, seven “gadget” classes in\n> Apache Commons Collections
    (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)\n> make object deserialization for the
    entire JVM process Turing complete\n> with an exec function. Since many business
    applications use object\n> deserialization to send messages across the network,
    it would be like\n> hiring a bank teller who was trained to hand over all the
    money in the\n> vault if asked to do so politely, and then entrusting that teller
    with\n> the key. The only thing that would keep a bank safe in such a\n> circumstance
    is that most people wouldn’t consider asking such a\n> question.\n> \n> * Google\n\n\n\n[1]:
    https://projects.spring.io/spring-security/\n[2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507\n[3]:
    https://cwe.mitre.org/data/definitions/502.html\n[4]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078\n"
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "< 4.2.3"
  - ">= 5 < 5.0.0.M2"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-4995
  cwe:
  - CWE-502
  credit:
  - Unknown
  references:
  - https://pivotal.io/security/cve-2017-4995
  - https://github.com/spring-projects/spring-security/issues/4370
  - https://github.com/spring-projects/spring-security/commit/947d11f433b78294942cb5ea56e8aa5c3a0ca439
  - https://github.com/spring-projects/spring-security/commit/5dee8534cd1b92952d10cc56335b5d5856f48f3b
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-31509
- id: snykio:maven:org.springframework.security:spring-security-core:2018-03-18
  title: Access Restriction Bypass
  description: |
    [org.springframework.security:spring-security-core][1] provides a
    comprehensive programming and configuration model for modern Java-based
    enterprise applications - on any kind of deployment platform.

    Affected versions of this package are vulnerable to Access Restriction
    Bypass. It does not consider URL path parameters when processing
    security constraints. By adding a URL path parameter with special
    encodings, an attacker may be able to bypass a security constraint.



    [1]: http://projects.spring.io/spring-framework/
    \n[org.springframework.security:spring-security-core][1] provides a
    comprehensive programming and configuration model for modern Java-based
    enterprise applications - on any kind of deployment platform.

    Affected versions of this package are vulnerable to Access Restriction
    Bypass. It does not consider URL path parameters when processing
    security constraints. By adding a URL path parameter with special
    encodings, an attacker may be able to bypass a security constraint.



    [1]: http://projects.spring.io/spring-framework/
    \n[org.springframework.security:spring-security-core][1] provides a
    comprehensive programming and configuration model for modern Java-based
    enterprise applications - on any kind of deployment platform.

    Affected versions of this package are vulnerable to Access Restriction
    Bypass. It does not consider URL path parameters when processing
    security constraints. By adding a URL path parameter with special
    encodings, an attacker may be able to bypass a security constraint.



    [1]: http://projects.spring.io/spring-framework/
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">= 4.1.0 < 4.1.5"
  - ">= 4.2.0 < 4.2.4"
  - ">= 5.0 < 5.0.3"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-1199
  cwe:
  - CWE-264
  credit:
  - Unknown
  references:
  - https://pivotal.io/security/cve-2018-1199
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGSPRINGFRAMEWORKSECURITY-32123
- id: victims:maven:org.springframework.security:spring-security-core:date
  title: Spring Security / MVC Path Matching Inconsistency
  description: 'Both Spring Security and the Spring Framework rely on URL pattern
    mappings for authorization and for mapping requests to controllers respectively.

'
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "<=4.1.0.RELEASE"
  patched_versions:
  - ">=4.1.1.RELEASE"
  severity: high
  package_manager: maven
  cve:
  - 2016-5007
  credit:
  - Victims CVE Database
  references:
  - https://pivotal.io/security/cve-2016-5007
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2016/5007.yaml
- id: victims:maven:org.springframework.security:spring-security-core:date
  title: Encoded "/" in path variables
  description: 'Spring Security does not consider URL path parameters when processing
    security constraints. By adding a URL path parameter with an encoded "/" to a
    request, an attacker may be able to bypass a security constraint[refer to link
    for full details]

'
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "<=3.2.9.RELEASE"
  - "<=4.1.3.RELEASE"
  - '4.1'
  - "<=4.2.0.RELEASE"
  - '4.2'
  patched_versions:
  - ">=3.2.10.RELEASE"
  - '3.2'
  - ">=4.1.4.RELEASE"
  - '4.1'
  - ">=4.2.1.RELEASE"
  - '4.2'
  severity: medium
  package_manager: maven
  cve:
  - 2016-9879
  credit:
  - Victims CVE Database
  references:
  - https://pivotal.io/security/cve-2016-9879
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2016/9879.yaml
- id: victims:maven:org.springframework.security:spring-security-core:date
  title: Jackson Configuration Allows Code Execution with Unknown Serialization Gadgets
  description: 'When configured to enable default typing, Jackson contained a deserialization
    vulnerability that could lead to arbitrary code execution. Jackson fixed this
    vulnerability by blacklisting known "deserialization gadgets".

'
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "<=4.2.2"
  - '4.2'
  - "==5.0.0.M1"
  patched_versions:
  - ">=4.2.3"
  - '4.2'
  - "==5.0.0.M2"
  severity: high
  package_manager: maven
  cve:
  - 2017-4995
  credit:
  - Victims CVE Database
  references:
  - http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-4995
  - https://nvd.nist.gov/vuln/detail/CVE-2017-4995
  - https://pivotal.io/security/cve-2017-4995
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2017/4995.yaml
- id: victims:maven:org.springframework.security:spring-security-core:date
  title: Spring Security's DaoAuthenticationProvider can reveal if a username is valid
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - ">=2.0.0"
  - '2'
  - ">=3.0.0.RELEASE"
  - '3.0'
  - ">=3.1.0.RELEASE"
  - '3.1'
  patched_versions:
  - ">=2.0.8.RELEASE"
  - '2'
  - ">=3.0.8.RELEASE"
  - '3.0'
  - ">=3.1.3.RELEASE"
  - '3.1'
  severity: low
  package_manager: maven
  cve:
  - 2012-5055
  credit:
  - Victims CVE Database
  references:
  - http://support.springsource.com/security/cve-2012-5055
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2012/5055.yaml
- id: victims:maven:org.springframework.security:spring-security-core:date
  title: Empty passwords may bypass authentication
  affected_package: org.springframework.security:spring-security-core
  vulnerable_versions:
  - "<=3.2.1.RELEASE"
  - '3.2'
  - "<=3.1.5.RELEASE"
  - '3.1'
  patched_versions:
  - ">=3.2.2.RELEASE"
  - '3.2'
  - ">=3.1.6.RELEASE"
  - '3.1'
  severity: high
  package_manager: maven
  cve:
  - 2014-0097
  credit:
  - Victims CVE Database
  references:
  - http://www.gopivotal.com/security/cve-2014-0097
  - https://bugzilla.redhat.com/CVE-2014-0097
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2014/0097.yaml
