---
- id: snykio:maven:org.apache.hive:hive-common:2016-10-31
  title: Information Exposure
  description: |
    [`org.apache.hive:hive-common`][1] Affected versions of the package are
    vulnerable to Information Exposure, also known as the replay attack. The
    is due to authenticating twice within a short period of time, when the
    context root is requested.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22hive-common%22
    \n[`org.apache.hive:hive-common`][1] Affected versions of the package are
    vulnerable to Information Exposure, also known as the replay attack. The
    is due to authenticating twice within a short period of time, when the
    context root is requested.



    [1]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22hive-common%22
  affected_package: org.apache.hive:hive-common
  vulnerable_versions:
  - ">= 1.2.0 <= 2.1.0"
  severity: medium
  package_manager: maven
  cwe:
  - CWE-200
  credit:
  - Unknown
  references:
  - https://issues.apache.org/jira/browse/HIVE-14984
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGAPACHEHIVE-30638
- id: snykio:maven:org.apache.hive:hive-common:2018-04-04
  title: Arbitrary File Write
  description: "[`org.apache.hive:hive-common`][1] acilitates reading, writing, and\nmanaging
    large datasets residing in distributed storage using SQL.\n\nApache Hive is vulnerable
    to Arbitrary File Write via the File Transfer\nProtocol (FTP) client functionality.
    Hive gives an SQL-like interface to\nquery data stored in various databases and
    file systems that integrate\nwith Hadoop. Among other things, it supports copying
    data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n    COPY FROM
    FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n      [TO
    [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE | NEW\n
    \     SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding the
    ssh authorized\\_keys file for\nthe root user, making it possible to login as
    root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\n[`org.apache.hive:hive-common`][1] acilitates
    reading, writing, and\nmanaging large datasets residing in distributed storage
    using SQL.\n\nApache Hive is vulnerable to Arbitrary File Write via the File Transfer\nProtocol
    (FTP) client functionality. Hive gives an SQL-like interface to\nquery data stored
    in various databases and file systems that integrate\nwith Hadoop. Among other
    things, it supports copying data from FTP\nservers, using the [COPY-FROM-FTP command][2].\n\n
    \   COPY FROM FTP host [USER user [PWD password]] [DIR directory] [FILES files_wildcard]\n
    \     [TO [LOCAL] target_directory] [options]\n    \n    options:\n      OVERWRITE
    | NEW\n      SUBDIR\n      SESSIONS num  \n\nA possible attack can be overriding
    the ssh authorized\\_keys file for\nthe root user, making it possible to login
    as root later on. Assumming\nthat Apache Hive instance connects to the attacker\\'s
    malicious FTP\nserver, to download some merchant data daily, by using the following\nquery:\n\n
    \   COPY FROM FTP remote.merchant.domain.com\n      USER 'foo' PWD '***'\n      DIR
    data/sales/in FILES  '.*'\n      TO /data/sales/raw OVERWRITE\n\nThe malicious
    FTP server would send back *path traversal* filenames to\nthe client. For instance,
    responding to a LIST command with\n`../../../../../../../home/root/.ssh/authorized_keys`.\n\nWhen
    Hive executes the above statement (assuming it’s running as root),\nroot’s `authorized_keys`
    ssh file will be overwritten with one known by\nthe attacker.\n\n\n\n[1]: https://hive.apache.org\n[2]:
    http://www.hplsql.org/copy-from-ftp\n\\nFTP is a standard network protocol used
    to transfer files between a\nclient and server. Out of the box, it does not offer
    a *download folder*\ncommand, but it does allow the following:\n\n1.  Listing
    all of the files in a remote folder (`LIST` or `NLST` FTP\n    commands)\n2.  For
    each file in the list results above: Download the file and save\n    it to a local
    folder (`GET` or `MGET` FTP commands)\n\nThe following is an example of some Java
    code downloading a folder,\nusing the Apache commons-net library:\n\n    private
    void downloadDirectory(FTPClient ftpClient, String remoteDir, String localDir)
    throws IOException\n    {\n      FTPFile[] subFiles = ftpClient.listFiles(remoteDir);\n
    \     for (FTPFile aFile : subFiles)\n      {\n        if (!aFile.isDirectory())\n
    \       {\n           String remoteFile = ftpClient.printWorkingDirectory() +
    File.separator + aFile.getName();\n           String localFile = localDir + File.separator
    + aFile.getName();\n    \n           OutputStream downloadedStream = new BufferedOutputStream(new
    FileOutputStream(new File(localFile)));\n           boolean success = ftpClient.retrieveFile(remoteFile,
    downloadedStream);\n           outputStream.close();            \n        }\n
    \     }\n    }\n\nThe code above, iterates over each file returned by the server,
    and\ndownloads it into a local destination folder. So for example, if the\nfirst
    file in the remote folder is named `passwd`, and the local\ndestination folder
    is `/var/data/sync/`, it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut
    if the FTP server turns malicious, and instead of responding to the\nLIST command
    with `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The
    code above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n\\nFTP
    is a standard network protocol used to transfer files between a\nclient and server.
    Out of the box, it does not offer a *download folder*\ncommand, but it does allow
    the following:\n\n1.  Listing all of the files in a remote folder (`LIST` or `NLST`
    FTP\n    commands)\n2.  For each file in the list results above: Download the
    file and save\n    it to a local folder (`GET` or `MGET` FTP commands)\n\nThe
    following is an example of some Java code downloading a folder,\nusing the Apache
    commons-net library:\n\n    private void downloadDirectory(FTPClient ftpClient,
    String remoteDir, String localDir) throws IOException\n    {\n      FTPFile[]
    subFiles = ftpClient.listFiles(remoteDir);\n      for (FTPFile aFile : subFiles)\n
    \     {\n        if (!aFile.isDirectory())\n        {\n           String remoteFile
    = ftpClient.printWorkingDirectory() + File.separator + aFile.getName();\n           String
    localFile = localDir + File.separator + aFile.getName();\n    \n           OutputStream
    downloadedStream = new BufferedOutputStream(new FileOutputStream(new File(localFile)));\n
    \          boolean success = ftpClient.retrieveFile(remoteFile, downloadedStream);\n
    \          outputStream.close();            \n        }\n      }\n    }\n\nThe
    code above, iterates over each file returned by the server, and\ndownloads it
    into a local destination folder. So for example, if the\nfirst file in the remote
    folder is named `passwd`, and the local\ndestination folder is `/var/data/sync/`,
    it\\'d end up downloading the\nfile to `/var/data/sync/passwd`.\n\nBut if the
    FTP server turns malicious, and instead of responding to the\nLIST command with
    `passwd`, it responds with `../../../../etc/passwd` as\nthe filename. The code
    above will end up placing the file into\n`/var/data/sync/../../../../etc/passwd`,
    practically overwriting\n`/etc/passwd` with the newly downloaded file.\n\nFor
    more information you can check out our [blog post][1].\n\n\n\n[1]: https://snyk.io/blog/attacking-an-ftp-client/\n"
  affected_package: org.apache.hive:hive-common
  vulnerable_versions:
  - ">= 2.1.0 < 2.3.3"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2018-1315
  cwe:
  - CWE-269
  credit:
  - Snyk Security Research Team
  references:
  - https://snyk.io/blog/attacking-an-ftp-client/
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGAPACHEHIVE-31662
- id: snykio:maven:org.apache.hive:hive-common:2018-04-09
  title: Arbitrary Files Access
  description: |
    [`org.apache.hive:hive-common`][1] facilitates reading, writing, and
    managing large datasets residing in distributed storage using SQL.

    Affected versions of the package are vulnerable to Arbitrary Files
    Access. A malicious user might use any xpath UDFs to expose the content
    of a file on the machine running `HiveServer2` owned by a `HiveServer2`
    user (usually hive) if `hive.server2.enable.doAs=false`.



    [1]: https://hive.apache.org
    \n[`org.apache.hive:hive-common`][1] facilitates reading, writing, and
    managing large datasets residing in distributed storage using SQL.

    Affected versions of the package are vulnerable to Arbitrary Files
    Access. A malicious user might use any xpath UDFs to expose the content
    of a file on the machine running `HiveServer2` owned by a `HiveServer2`
    user (usually hive) if `hive.server2.enable.doAs=false`.



    [1]: https://hive.apache.org
    \n[`org.apache.hive:hive-common`][1] facilitates reading, writing, and
    managing large datasets residing in distributed storage using SQL.

    Affected versions of the package are vulnerable to Arbitrary Files
    Access. A malicious user might use any xpath UDFs to expose the content
    of a file on the machine running `HiveServer2` owned by a `HiveServer2`
    user (usually hive) if `hive.server2.enable.doAs=false`.



    [1]: https://hive.apache.org
  affected_package: org.apache.hive:hive-common
  vulnerable_versions:
  - ">= 0.6.0 < 2.3.3"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2018-1284
  cwe:
  - CWE-284
  credit:
  - Unknown
  references:
  - https://lists.apache.org/thread.html/29184dbce4a37be2af36e539ecb479b1d27868f73ccfdff46c7174b4@%3Cdev.hive.apache.org%3E
  source_url: https://snyk.io/vuln/SNYK-JAVA-ORGAPACHEHIVE-32203
